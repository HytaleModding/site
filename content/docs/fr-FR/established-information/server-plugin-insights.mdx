---
title: Aperçus du code serveur
description: Slikey a partagé quelques aperçus sur le code serveur le 15/12/2025. Ce document couvre les points clés et les conclusions de cette discussion.
---

<Callout type="info" title="Note">
  Les informations suivantes sont basées sur les aperçus partagés par le Directeur Technique Slikey le 15 décembre 2025 sur le serveur Discord de Hytale. Elles fournissent une vue d'ensemble de l'architecture du code serveur et des capacités des plugins.

  La majorité de ce document est constituée de citations directes de Slikey avec un minimum de commentaires. C'est plutôt pour préserver l'information partagée que pour la reformuler.
</Callout>

# Code source du serveur

Le serveur sera publié en source partagée - nous aurons le code source sans obfuscation et tous leurs commentaires.

### Licence

La licence permet l'utilisation pour tout ce qui est **lié à Hytale**, donc tant que vous n'utilisez pas le serveur / le code source pour faire votre propre jeu ou vendre leurs algorithmes.

# Système de permissions

Après avoir été interrogé sur le serveur Hytale Modding, l'Architecte Principal Zero a répondu :

C'est assez basique, donc n'attendez pas grand-chose, mais oui nous avons un système de permissions intégré. Il supporte aussi l'implémentation de votre propre backend. Par ex. si vous vouliez le stocker dans une base de données.

![Extrait du code de permission](/assets/premission-system.png)

# Implémentation de la génération de monde

Le bloc de texte suivant provient directement de l'Architecte Principal Zero :

Vous pouvez totalement implémenter une génération de monde personnalisée dans un plugin super facilement. Donc si vous voulez une configuration ou une logique totalement différente pour générer le terrain, vous pouvez l'ajouter dans un plugin puis configurer un monde pour l'utiliser.
Nous avons certaines choses qui chargent des prefabs et il y a du code existant dans les générateurs de monde actuels qui pourrait possiblement être réutilisé mais pas d'APIs spécifiquement pour les détails de la génération elle-même.

```java
public interface IWorldGenProvider {
    BuilderCodecMapCodec<IWorldGenProvider> CODEC = new BuilderCodecMapCodec<>("Type", true);

    IWorldGen getGenerator() throws WorldGenLoadException;
}
```

```java
public interface IWorldGen {
    @Nullable
    WorldGenTimingsCollector getTimings();

    CompletableFuture<GeneratedChunk> generate(int seed, long index, int x, int z, LongPredicate stillNeeded);

    @Deprecated
    Transform[] getSpawnPoints(int seed);

    @Nonnull
    default ISpawnProvider getDefaultSpawnProvider(int seed) {
        return new FitToHeightMapSpawnProvider(new IndividualSpawnProvider(getSpawnPoints(seed)));
    }

    default void shutdown() {}
}
```

# Extraits de code serveur

Quelques extraits de code d'un plugin qu'ils ont fait ont aussi été partagés. Les extraits suivants sont des citations directes du Directeur Technique Slikey :

## Plugin BlockSpawner

D'accord, je vais lâcher quelques extraits de code ici pour un simple plugin appelé « BlockSpawner » qui se transformera en un bloc « aléatoire » quand il est placé dans le monde selon les règles configurées.

Il y a plus de code ici en général mais ça montre le système d'Assets et la disposition du plugin. Vous pouvez voir que le système d'assets définit des « Codecs » qui sont utilisés pour sérialiser et désérialiser les données. En utilisant ces codecs nous pouvons générer des schémas.
Disons que vous vous connectez à un serveur et ouvrez l'éditeur d'assets : le serveur enverra ces schémas - donc chaque type d'asset défini côté serveur, même les vôtres, devient maintenant partie de l'éditeur d'assets sur le client - pas besoin de faire quoi que ce soit, vous profitez simplement de l'interface de l'éditeur pour créer vos assets que vous avez définis.

![Code Block Spawner 1](/assets/blockspawner-code-1.png)
![Code Block Spawner 2](/assets/blockspawner-code-2.png)
![Code Block Spawner 3](/assets/blockspawner-code-3.png)
![Manifest Block Spawner](/assets/blockspawner-manifest.png)

> je suppose que cette partie montre aussi un peu comment nous utilisons des constantes pour stocker des clés de langue - Slikey
> (en référence à l'image ci-dessous)

![Constantes pour stocker les clés de langue](/assets/constants.png)

> vous pouvez complètement personnaliser le fournisseur de stockage de chunks, nous par exemple en avons fait un qui est juste vide où il ne charge aucun chunk depuis le disque
> vous pourriez ajouter un MySQLChunkStorageProvider et il pourrait lire les données depuis une base de données
> et c'est pareil pour la génération de monde, vous pouvez simplement implémenter cette interface pour générer un générateur de monde - slikey

![Chunks 1](/assets/chunks-1.png)
![Chunks 2](/assets/chunks-2.png)
![Chunks 3](/assets/chunks-3.png)

> je veux dire ici sont définies toutes les armes, vous me direz, évidemment vous découvrirez des limitations mais je pense qu'il y a beaucoup de place pour faire des changements - ce truc est en fait difficile cependant, il y a beaucoup de qualité de vie à avoir ici.

![Armes 1](/assets/weapons-1.png)
