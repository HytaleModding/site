---
title: Les bases de l'ECS Hytale
description: Dans ce guide, vous apprendrez les bases du puissant système ECS de Hytale ainsi qu'à créer votre propre composant, un système, et à travailler avec d'autres systèmes pour créer une logique de gameplay.
authors:
  - name: oskarscot
    link: https://oskar.scot
---

## Store

La classe `Store` est le cœur du système ECS de Hytale, elle est responsable du stockage des entités. Si vous avez besoin d'accéder à une entité, vous avez besoin d'accéder au store. Elle utilise un concept appelé Archétypes où les données sont regroupées en chunks. Par exemple, si nous avons 100 Trorks, ils seront regroupés ensemble avec leurs composants afin d'être étroitement packés ensemble et plus rapides à récupérer.

## EntityStore

En parcourant le code serveur de Hytale, vous trouverez que `Store` sera de type `EntityStore`. Ce nom peut être trompeur car il pourrait suggérer que c'est un `Store` pour les entités. Mais n'avons-nous pas dit que le `Store` de base stocke déjà les entités ? La classe `EntityStore` implémente `WorldProvider`, ce qui signifie que `EntityStore` est responsable de l'accès aux entités dans un `World` Hytale spécifique. Elle maintient des maps internes `entitiesByUuid` et `networkIdToRef`, vous permettant de trouver une entité spécifique par son ID persistant ou son ID réseau.

Chaque Entité a un `UUIDComponent` ainsi qu'un `NetworkId` qui sont utilisés par l'`EntityStore` pour rechercher des entités à l'intérieur du `Store`.

## Ref (Référence)

Pour ceux familiers avec des langages comme C++, vous pouvez probablement déjà deviner ce qu'est cette classe juste par son nom. Cependant, une Ref est un « handle » ou pointeur sûr vers une entité. Vous ne devriez **JAMAIS** stocker une référence directe à un objet entité, vous utilisez une Ref à la place. Elle trace si une entité est toujours vivante. Si vous appelez `validate()` sur une Ref pour une entité qui a été supprimée, elle lance une exception.

## Composants du joueur

Dans Hytale, un « Joueur » n'est pas qu'un seul objet. C'est une seule entité composée de plusieurs composants spécialisés. Comprendre la différence entre `Player` et `PlayerRef` est crucial pour le modding.

### PlayerRef

Malgré son nom, PlayerRef est un Composant, pas un handle. Il représente la connexion et l'identité du joueur. C'est un composant spécial qui reste actif tant que le joueur est connecté au serveur, même si le joueur change de monde. Les données clés qu'il stocke sont le nom d'utilisateur du joueur, l'UUID, la langue ainsi que le gestionnaire de paquets.

### Player

Le composant `Player` représente la présence physique du joueur. Il n'existe que lorsque le joueur est réellement spawné dans un monde. Fournissant l'accès aux données spécifiques au gameplay, ce composant diffère par monde.

Pour interagir avec une entité, vous utilisez le `Store` pour récupérer ses composants via leur `ComponentType`. Parce que Hytale utilise un système découplé, vous n'appelez pas `entity.getHealth()`. Au lieu de cela, vous demandez au `Store` les données de santé associées à la `Ref` de cette entité.

```java
@Override
protected void execute(@Nonnull CommandContext commandContext, @Nonnull Store<EntityStore> store, 
    @Nonnull Ref<EntityStore> ref, @Nonnull PlayerRef playerRef, @Nonnull World world) {
  Player player = store.getComponent(ref, Player.getComponentType());
  UUIDComponent component = store.getComponent(ref, UUIDComponent.getComponentType());
  TransformComponent transform = store.getComponent(ref, TransformComponent.getComponentType());
  player.sendMessage(Message.raw("UUIDComponent : " + component.getUuid()));
  player.sendMessage(Message.raw("Transform : " + transform.getPosition()));
}
```

Ici nous utilisons le `Store<EntityStore>` pour accéder au composant `Player` en utilisant la `Ref<EntityStore>`. Nous pouvons faire la même chose pour d'autres composants comme l'`UUIDComponent` ou le `TransformComponent` pour récupérer le Transform de l'entité contenant la position et la rotation.

## Composants

Les Composants sont de purs conteneurs de données. Ils contiennent l'état mais ne contiennent aucune logique. Dans Hytale, les composants doivent implémenter `Component<EntityStore>` et fournir une méthode clone pour que l'ECS puisse les copier quand nécessaire.

```java
public class PoisonComponent implements Component<EntityStore> {

  private float damagePerTick;
  private float tickInterval;
  private int remainingTicks;
  private float elapsedTime;

  public PoisonComponent() {
    this(5f, 1.0f, 10);
  }

  public PoisonComponent(float damagePerTick, float tickInterval, int totalTicks) {
    this.damagePerTick = damagePerTick;
    this.tickInterval = tickInterval;
    this.remainingTicks = totalTicks;
    this.elapsedTime = 0f;
  }

  public PoisonComponent(PoisonComponent other) {
    this.damagePerTick = other.damagePerTick;
    this.tickInterval = other.tickInterval;
    this.remainingTicks = other.remainingTicks;
    this.elapsedTime = other.elapsedTime;
  }

  @Nullable
  @Override
  public Component<EntityStore> clone() {
    return new PoisonComponent(this);
  }

  public float getDamagePerTick() {
    return damagePerTick;
  }

  public float getTickInterval() {
    return tickInterval;
  }

  public int getRemainingTicks() {
    return remainingTicks;
  }

  public float getElapsedTime() {
    return elapsedTime;
  }

  public void addElapsedTime(float dt) {
    this.elapsedTime += dt;
  }

  public void resetElapsedTime() {
    this.elapsedTime = 0f;
  }

  public void decrementRemainingTicks() {
    this.remainingTicks--;
  }

  public boolean isExpired() {
    return this.remainingTicks <= 0;
  }
}
```

Le constructeur par défaut est requis pour la factory d'enregistrement. Le constructeur de copie est utilisé par `clone()` que l'ECS appelle en interne quand il a besoin de dupliquer les données d'un composant.

## Systèmes

Les Systèmes sont là où vit la logique. Alors que les composants sont de purs conteneurs de données, les systèmes opèrent sur les entités qui correspondent à des requêtes de composants spécifiques. L'ordonnanceur ECS exécute les systèmes à chaque tick, en passant uniquement les entités qui ont les composants dont le système se soucie.

### EntityTickingSystem

Le type de système le plus courant. Il s'exécute à chaque tick et traite chaque entité correspondant à sa requête individuellement.

```java
public class PoisonSystem extends EntityTickingSystem<EntityStore> {

  private final ComponentType<EntityStore, PoisonComponent> poisonComponentType;

  public PoisonSystem(ComponentType<EntityStore, PoisonComponent> poisonComponentType) {
    this.poisonComponentType = poisonComponentType;
  }

  @Override
  public void tick(float dt, int index, @Nonnull ArchetypeChunk<EntityStore> archetypeChunk,
      @Nonnull Store<EntityStore> store, @Nonnull CommandBuffer<EntityStore> commandBuffer) {

    PoisonComponent poison = archetypeChunk.getComponent(index, poisonComponentType);
    Ref<EntityStore> ref = archetypeChunk.getReferenceTo(index);

    poison.addElapsedTime(dt);

    if (poison.getElapsedTime() >= poison.getTickInterval()) {
      poison.resetElapsedTime();

      Damage damage = new Damage(Damage.NULL_SOURCE, DamageCause.OUT_OF_WORLD, poison.getDamagePerTick());
      DamageSystems.executeDamage(ref, commandBuffer, damage);

      poison.decrementRemainingTicks();
    }

    if (poison.isExpired()) {
      commandBuffer.removeComponent(ref, poisonComponentType);
    }
  }

  @Nullable
  @Override
  public SystemGroup<EntityStore> getGroup() {
    return DamageModule.get().getGatherDamageGroup();
  }

  @Nonnull
  @Override
  public Query<EntityStore> getQuery() {
    return Query.and(this.poisonComponentType);
  }
}
```

La méthode `tick` reçoit `dt` qui est le delta time depuis le dernier tick. Cela vous permet d'accumuler du temps pour une logique basée sur des intervalles plutôt que de compter les ticks. L'`ArchetypeChunk` vous donne accès aux composants de l'entité via l'index, et `getReferenceTo` retourne la `Ref` dont vous avez besoin pour émettre des commandes.

### TickingSystem

S'exécute une fois par tick globalement, pas par entité. Utilisez ceci pour des mises à jour à l'échelle du monde ou une logique qui ne cible pas des entités spécifiques.

```java
public class GlobalUpdateSystem extends TickingSystem<EntityStore> {

  @Override
  public void tick(float dt, int index, Store<EntityStore> store) {
    World world = store.getExternalData().getWorld();
  }
}
```

### DelayedEntitySystem

Comme `EntityTickingSystem` mais avec un délai intégré. Le constructeur prend un float représentant les secondes entre les exécutions.

```java
public class HealthRegenSystem extends DelayedEntitySystem<EntityStore> {

  public HealthRegenSystem() {
    super(1.0f);
  }

  @Override
  public void tick(float dt, int index, @Nonnull ArchetypeChunk<EntityStore> archetypeChunk,
      @Nonnull Store<EntityStore> store, @Nonnull CommandBuffer<EntityStore> commandBuffer) {
    // S'exécute toutes les 1 seconde par entité correspondante
  }

  @Nonnull
  @Override
  public Query<EntityStore> getQuery() {
    return Query.and(Player.getComponentType());
  }
}
```

## Requêtes

Les Requêtes filtrent quelles entités un système traite. L'ECS ne passe des entités à la méthode `tick` de votre système que si elles ont tous les composants spécifiés dans la requête.

```java
// Composant unique - toute entité avec PoisonComponent
Query.and(poisonComponentType)

// Plusieurs composants - entités avec les deux
Query.and(poisonComponentType, Player.getComponentType())

// Exclusion - joueurs qui ne sont pas morts
Query.and(Player.getComponentType(), Query.not(DeathComponent.getComponentType()))
```

## CommandBuffer

Le `CommandBuffer` met en file d'attente les changements aux entités. Utilisez-le au lieu de modifier le store directement pour garantir la sécurité des threads et un ordre correct. Vous l'utiliserez pour ajouter des composants, supprimer des composants et exécuter des dégâts.

```java
commandBuffer.addComponent(ref, componentType, new MyComponent());

commandBuffer.removeComponent(ref, componentType);

MyComponent comp = commandBuffer.getComponent(ref, componentType);
```

## SystemGroups et Dépendances

Les Systèmes peuvent déclarer à quel groupe ils appartiennent et quelles dépendances ils ont. Ceci contrôle l'ordre d'exécution, ce qui est critique pour les systèmes qui interagissent.

```java
@Nullable
@Override
public SystemGroup<EntityStore> getGroup() {
  return DamageModule.get().getGatherDamageGroup();
}
```

Pour un ordre plus complexe, vous pouvez surcharger `getDependencies` :

```java
@Nonnull
public Set<Dependency<EntityStore>> getDependencies() {
  return Set.of(
    new SystemGroupDependency(Order.AFTER, DamageModule.get().getFilterDamageGroup()),
    new SystemDependency(Order.BEFORE, PlayerSystems.ProcessPlayerInput.class)
  );
}
```

Le système de dégâts est un bon exemple de pourquoi l'ordre compte. Le pipeline de dégâts de Hytale a quatre étapes : GatherDamageGroup collecte les sources de dégâts, FilterDamageGroup applique les réductions et annulations, puis les dégâts sont appliqués à la santé, et enfin InspectDamageGroup gère les effets secondaires comme les particules et les sons. Si ceux-ci s'exécutaient dans le mauvais ordre, vous joueriez des animations de mort avant que l'entité ne meure ou appliqueriez la réduction d'armure après que la santé ait déjà été soustraite.

## Enregistrer les Composants et Systèmes

Les Composants et systèmes doivent être enregistrés pendant la configuration du plugin. L'`EntityStoreRegistry` gère cela.

```java
public final class ExamplePlugin extends JavaPlugin {

  private static ExamplePlugin instance;
  private ComponentType<EntityStore, PoisonComponent> poisonComponent;

  public ExamplePlugin(@Nonnull JavaPluginInit init) {
    super(init);
    instance = this;
  }

  @Override
  protected void setup() {
    this.getCommandRegistry().registerCommand(new ExampleCommand());
    this.getEventRegistry().registerGlobal(PlayerReadyEvent.class, ExampleEvent::onPlayerReady);
    this.getEventRegistry().registerGlobal(PlayerChatEvent.class, ChatFormatter::onPlayerChat);

    this.poisonComponent = this.getEntityStoreRegistry()
        .registerComponent(PoisonComponent.class, PoisonComponent::new);
    this.getEntityStoreRegistry().registerSystem(new PoisonSystem(this.poisonComponent));
  }

  public ComponentType<EntityStore, PoisonComponent> getPoisonComponentType() {
    return poisonComponent;
  }

  public static ExamplePlugin get() {
    return instance;
  }
}
```

La méthode `registerComponent` retourne un `ComponentType` qui agit comme une clé pour accéder à ce type de composant dans tout votre plugin. Stockez-le comme un champ et passez-le à tous les systèmes qui en ont besoin. Le deuxième argument est une factory pour créer des instances par défaut.

## Exemple pratique : Système de poison

En mettant tout ensemble, voici un effet de poison complet. Quand il est appliqué à n'importe quelle entité, il inflige des dégâts à un intervalle défini jusqu'à expiration et se supprime lui-même.

```java
package scot.oskar.hytaletemplate.components;

import com.hypixel.hytale.component.Component;
import com.hypixel.hytale.server.core.universe.world.storage.EntityStore;
import javax.annotation.Nullable;

public class PoisonComponent implements Component<EntityStore> {

  private float damagePerTick;
  private float tickInterval;
  private int remainingTicks;
  private float elapsedTime;

  public PoisonComponent() {
    this(5f, 1.0f, 10);
  }

  public PoisonComponent(float damagePerTick, float tickInterval, int totalTicks) {
    this.damagePerTick = damagePerTick;
    this.tickInterval = tickInterval;
    this.remainingTicks = totalTicks;
    this.elapsedTime = 0f;
  }

  public PoisonComponent(PoisonComponent other) {
    this.damagePerTick = other.damagePerTick;
    this.tickInterval = other.tickInterval;
    this.remainingTicks = other.remainingTicks;
    this.elapsedTime = other.elapsedTime;
  }

  @Nullable
  @Override
  public Component<EntityStore> clone() {
    return new PoisonComponent(this);
  }

  public float getDamagePerTick() {
    return damagePerTick;
  }

  public float getTickInterval() {
    return tickInterval;
  }

  public int getRemainingTicks() {
    return remainingTicks;
  }

  public float getElapsedTime() {
    return elapsedTime;
  }

  public void addElapsedTime(float dt) {
    this.elapsedTime += dt;
  }

  public void resetElapsedTime() {
    this.elapsedTime = 0f;
  }

  public void decrementRemainingTicks() {
    this.remainingTicks--;
  }

  public boolean isExpired() {
    return this.remainingTicks <= 0;
  }
}
```

```java
package scot.oskar.hytaletemplate.systems;

import com.hypixel.hytale.component.ArchetypeChunk;
import com.hypixel.hytale.component.CommandBuffer;
import com.hypixel.hytale.component.ComponentType;
import com.hypixel.hytale.component.Ref;
import com.hypixel.hytale.component.Store;
import com.hypixel.hytale.component.SystemGroup;
import com.hypixel.hytale.component.query.Query;
import com.hypixel.hytale.component.system.tick.EntityTickingSystem;
import com.hypixel.hytale.server.core.modules.entity.damage.Damage;
import com.hypixel.hytale.server.core.modules.entity.damage.DamageCause;
import com.hypixel.hytale.server.core.modules.entity.damage.DamageModule;
import com.hypixel.hytale.server.core.modules.entity.damage.DamageSystems;
import com.hypixel.hytale.server.core.universe.world.storage.EntityStore;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import scot.oskar.hytaletemplate.components.PoisonComponent;

public class PoisonSystem extends EntityTickingSystem<EntityStore> {

  private final ComponentType<EntityStore, PoisonComponent> poisonComponentType;

  public PoisonSystem(ComponentType<EntityStore, PoisonComponent> poisonComponentType) {
    this.poisonComponentType = poisonComponentType;
  }

  @Override
  public void tick(float dt, int index, @Nonnull ArchetypeChunk<EntityStore> archetypeChunk,
      @Nonnull Store<EntityStore> store, @Nonnull CommandBuffer<EntityStore> commandBuffer) {

    PoisonComponent poison = archetypeChunk.getComponent(index, poisonComponentType);
    Ref<EntityStore> ref = archetypeChunk.getReferenceTo(index);

    poison.addElapsedTime(dt);

    if (poison.getElapsedTime() >= poison.getTickInterval()) {
      poison.resetElapsedTime();

      Damage damage = new Damage(Damage.NULL_SOURCE, DamageCause.OUT_OF_WORLD, poison.getDamagePerTick());
      DamageSystems.executeDamage(ref, commandBuffer, damage);

      poison.decrementRemainingTicks();
    }

    if (poison.isExpired()) {
      commandBuffer.removeComponent(ref, poisonComponentType);
    }
  }

  @Nullable
  @Override
  public SystemGroup<EntityStore> getGroup() {
    return DamageModule.get().getGatherDamageGroup();
  }

  @Nonnull
  @Override
  public Query<EntityStore> getQuery() {
    return Query.and(this.poisonComponentType);
  }
}
```

```java
package scot.oskar.hytaletemplate.commands;

public class ExampleCommand extends AbstractPlayerCommand {

  public ExampleCommand() {
    super("test", "Super commande de test !");
  }

  @Override
  protected void execute(@Nonnull CommandContext commandContext, @Nonnull Store<EntityStore> store, 
      @Nonnull Ref<EntityStore> ref, @Nonnull PlayerRef playerRef, @Nonnull World world) {
    Player player = store.getComponent(ref, Player.getComponentType());
    PoisonComponent poison = new PoisonComponent(3f, 0.5f, 8);
    store.addComponent(ref, ExamplePlugin.get().getPoisonComponentType(), poison);
    player.sendMessage(Message.raw("Vous avez été empoisonné !").color(Color.GREEN).bold(true));
  }
}
```

```java
package scot.oskar.hytaletemplate;

public final class ExamplePlugin extends JavaPlugin {

  private static ExamplePlugin instance;
  private ComponentType<EntityStore, PoisonComponent> poisonComponent;

  public ExamplePlugin(@Nonnull JavaPluginInit init) {
    super(init);
    instance = this;
  }

  @Override
  protected void setup() {
    this.getCommandRegistry().registerCommand(new ExampleCommand());
    this.getEventRegistry().registerGlobal(PlayerReadyEvent.class, ExampleEvent::onPlayerReady);
    this.getEventRegistry().registerGlobal(PlayerChatEvent.class, ChatFormatter::onPlayerChat);

    this.poisonComponent = this.getEntityStoreRegistry()
        .registerComponent(PoisonComponent.class, PoisonComponent::new);
    this.getEntityStoreRegistry().registerSystem(new PoisonSystem(this.poisonComponent));
  }

  public ComponentType<EntityStore, PoisonComponent> getPoisonComponentType() {
    return poisonComponent;
  }

  public static ExamplePlugin get() {
    return instance;
  }
}
```

La requête utilise uniquement `poisonComponentType`, ce qui signifie que le système traitera n'importe quelle entité avec un `PoisonComponent`, pas seulement les joueurs. Cela le rend flexible pour empoisonner des PNJ, des mobs ou n'importe quelle entité vivante. Le système se place dans le `GatherDamageGroup` afin que les dégâts qu'il crée passent par le pipeline complet de dégâts incluant la réduction d'armure et les vérifications d'invulnérabilité.

À suivre.
