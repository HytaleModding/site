---
title: 08 - Encapsulation et Modificateurs d'Accès
description: Apprenez à protéger et contrôler l'accès aux données de vos classes.
---

L'encapsulation consiste à cacher les détails internes d'une classe et à contrôler comment ses données sont accessibles et modifiées. Cela prévient les bugs et rend votre code plus maintenable.

## Le Problème Sans Encapsulation

```java
public class Player {
    public String name;
    public int health;
    public int maxHealth;
}

public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        player.health = 100;
        player.maxHealth = 100;
        
        // Oops! Someone can break the rules
        player.health = 500;      // Health over maximum!
        player.health = -50;      // Negative health!
        player.name = "";         // Empty name!
    }
}
```

Sans protection, n'importe qui peut définir des valeurs invalides !

## Modificateurs d'Accès

Java a des mots-clés qui contrôlent qui peut accéder aux membres de votre classe :

| Modificateur | Classe | Package | Sous-classe | Monde |
| ------------ | ------ | ------- | ----------- | ----- |
| `public`     | ✓      | ✓       | ✓           | ✓     |
| `protected`  | ✓      | ✓       | ✓           | ✗     |
| (aucun)      | ✓      | ✓       | ✗           | ✗     |
| `private`    | ✓      | ✗       | ✗           | ✗     |

**Pour l'instant, concentrez-vous sur :**

* `public` - Tout le monde peut accéder
* `private` - Seule cette classe peut accéder

## Rendre les Propriétés Privées

```java
public class Player {
    private String name;
    private int health;
    private int maxHealth;
    
    public Player(String name, int maxHealth) {
        this.name = name;
        this.health = maxHealth;
        this.maxHealth = maxHealth;
    }
}
```

Maintenant vous ne pouvez pas accéder aux propriétés directement :

```java
Player player = new Player("Alice", 100);
player.health = 500;  // ❌ Error! health is private
```

## Getters et Setters

Pour accéder aux propriétés privées, créez des méthodes **getter** et **setter** :

```java
public class Player {
    private String name;
    private int health;
    private int maxHealth;
    
    public Player(String name, int maxHealth) {
        this.name = name;
        this.health = maxHealth;
        this.maxHealth = maxHealth;
    }
    
    // Getter - returns the value
    public int getHealth() {
        return health;
    }
    
    // Setter - sets the value with validation
    public void setHealth(int health) {
        if (health < 0) {
            this.health = 0;
        } else if (health > maxHealth) {
            this.health = maxHealth;
        } else {
            this.health = health;
        }
    }
    
    public String getName() {
        return name;
    }
    
    public int getMaxHealth() {
        return maxHealth;
    }
}
```

Maintenant vous pouvez interagir en toute sécurité avec l'objet :

```java
Player player = new Player("Alice", 100);

player.setHealth(150);  // Automatically capped at 100
System.out.println(player.getHealth());  // 100

player.setHealth(-20);  // Automatically set to 0
System.out.println(player.getHealth());  // 0
```

<Callout type="info" title="Nommage des Getters et Setters">
  Suivez les conventions de nommage Java :

  * **Getter** : `get` + nom de propriété (capitalisé)
  * **Setter** : `set` + nom de propriété (capitalisé)
  * **Booléen** : `is` + nom de propriété (capitalisé)

  ```java
  private int health;
  public int getHealth() { }
  public void setHealth(int health) { }

  private boolean alive;
  public boolean isAlive() { }
  public void setAlive(boolean alive) { }

  private String name;
  public String getName() { }
  public void setName(String name) { }
  ```
</Callout>

## Avantages de l'Encapsulation

### 1. Validation

```java
public class Item {
    private int durability;
    private int maxDurability;
    
    public void setDurability(int durability) {
        if (durability < 0) {
            this.durability = 0;
        } else if (durability > maxDurability) {
            this.durability = maxDurability;
        } else {
            this.durability = durability;
        }
    }
    
    public boolean isBroken() {
        return durability <= 0;
    }
}
```

### 2. Propriétés en Lecture Seule

Parfois vous ne voulez pas de setter :

```java
public class Monster {
    private String id;  // Should never change
    private int health;
    
    public Monster(String id, int health) {
        this.id = id;
        this.health = health;
    }
    
    // Getter only - no setter!
    public String getId() {
        return id;
    }
    
    public int getHealth() {
        return health;
    }
    
    public void setHealth(int health) {
        this.health = health;
    }
}
```

### 3. Propriétés Calculées

Les getters n'ont pas besoin de retourner un champ directement :

```java
public class Player {
    private int health;
    private int maxHealth;
    
    public int getHealth() {
        return health;
    }
    
    // Computed property
    public double getHealthPercentage() {
        return (health * 100.0) / maxHealth;
    }
    
    // Computed property
    public boolean isLowHealth() {
        return getHealthPercentage() < 25;
    }
}
```

## Exemples Pratiques

### Objet avec Durabilité

```java
public class Tool {
    private String name;
    private int durability;
    private int maxDurability;
    private boolean broken;
    
    public Tool(String name, int maxDurability) {
        this.name = name;
        this.durability = maxDurability;
        this.maxDurability = maxDurability;
        this.broken = false;
    }
    
    public void use() {
        if (broken) {
            System.out.println(name + " is broken!");
            return;
        }
        
        durability--;
        System.out.println(name + " used. Durability: " + durability);
        
        if (durability <= 0) {
            broken = true;
            System.out.println(name + " broke!");
        }
    }
    
    public void repair() {
        durability = maxDurability;
        broken = false;
        System.out.println(name + " repaired!");
    }
    
    // Getters
    public String getName() {
        return name;
    }
    
    public int getDurability() {
        return durability;
    }
    
    public boolean isBroken() {
        return broken;
    }
    
    public double getDurabilityPercentage() {
        return (durability * 100.0) / maxDurability;
    }
}
```

### Exemple de Compte Bancaire

```java
public class PlayerWallet {
    private int gold;
    private int silver;
    
    public PlayerWallet() {
        this.gold = 0;
        this.silver = 0;
    }
    
    public void addGold(int amount) {
        if (amount > 0) {
            gold += amount;
            System.out.println("Added " + amount + " gold");
        }
    }
    
    public boolean spendGold(int amount) {
        if (amount > gold) {
            System.out.println("Not enough gold!");
            return false;
        }
        
        gold -= amount;
        System.out.println("Spent " + amount + " gold");
        return true;
    }
    
    public int getGold() {
        return gold;
    }
    
    public int getTotalValue() {
        // 1 gold = 100 silver
        return gold * 100 + silver;
    }
}
```

### Système de Bloc Protégé

```java
public class ProtectedBlock {
    private int x, y, z;
    private String type;
    private String owner;
    private boolean locked;
    
    public ProtectedBlock(int x, int y, int z, String type, String owner) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.type = type;
        this.owner = owner;
        this.locked = true;
    }
    
    public boolean canBreak(String playerName) {
        if (!locked) {
            return true;
        }
        
        return playerName.equals(owner);
    }
    
    public void unlock(String playerName) {
        if (playerName.equals(owner)) {
            locked = false;
            System.out.println("Block unlocked");
        } else {
            System.out.println("You don't own this block!");
        }
    }
    
    // Getters only - position and owner shouldn't change
    public int getX() {
        return x;
    }
    
    public int getY() {
        return y;
    }
    
    public int getZ() {
        return z;
    }
    
    public String getOwner() {
        return owner;
    }
    
    public boolean isLocked() {
        return locked;
    }
}
```

## Quand Utiliser Private vs Public

<Callout type="info" title="Règles Générales">
  **Rendez-le privé par défaut !** Ne rendez les choses publiques que si elles doivent être accessibles de l'extérieur.

  **Private :**

  * Données internes (santé, position, inventaire)
  * Méthodes d'aide utilisées uniquement dans la classe
  * Tout ce qui nécessite une validation

  **Public :**

  * Méthodes qui définissent le comportement de la classe
  * Constructeur
  * Méthodes que d'autres classes doivent appeler

  ```java
  public class Example {
      // Private - internal data
      private int internalCounter;
      private String secretKey;
      
      // Public - part of the interface
      public void doSomething() {
          // Uses private helper method
          validateData();
      }
      
      // Private - internal helper
      private void validateData() {
          // ...
      }
  }
  ```
</Callout>

## Le Mot-clé `final`

`final` signifie qu'une variable ne peut pas être changée après avoir été définie :

```java
public class Player {
    private final String id;  // Can't change after creation
    private String name;      // Can change
    private int health;       // Can change
    
    public Player(String id, String name) {
        this.id = id;
        this.name = name;
    }
    
    public String getId() {
        return id;
    }
    
    // No setId() - it's final!
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
```

## Le Mot-clé `static`

### Membres Statiques

Une classe peut définir deux types de membres :

* **Membres d'instance** — possédés par chaque objet (chaque instance a sa propre copie).

* **Membres statiques** — possédés par la classe (une copie partagée pour tout le type).

En termes simples : les membres d'instance appartiennent aux objets ; les membres statiques appartiennent à la classe elle-même et sont partagés par tous les objets de ce type.

#### Déclaration

```java
    /* (access modifier) */ static ... memberName; 
```

#### Exemple

```java
class Data {
    public int x; // Instanced member
    public static int y = 1000; // Static member

    // Instanced member:
    // can access to both static and non-static members
    public void foo() {
        x = 100; // OK - same as this.x = 100;
        y = 100; // OK - same as Data.y = 200;
    }

    // Static member:
    // cannot access to non-static variables
    public static void bar() {
        x = 100; // Error: non-static variable x cannot be renference from a static context
        y = 100; // OK
    }
}
```

#### Accéder aux membres statiques

```java
Data data = new Data();
data.x = 1000; // OK

data.y = 1000; // OK-ish - not really suggested; it's better to use Data.y
Data.y = 1000; // OK - best practice

Data.x = 1000; // Error: cannot access instanced variables in a static context
```

### Champs Statiques

Un champ statique représente un membre de données possédé par le type de classe plutôt que par l'objet. Les champs statiques sont également stockés dans un emplacement mémoire spécifique qui est partagé entre toutes les instances d'objet créées.

Il est déclaré comme suit :

```java
/* (access modifier) (optional) */ static /* final/volatile (optional) */ fieldName;
```

Prenons le même exemple de classe Data et ajoutons ce constructeur :

```java
public Data() {
    y++; // remember that's the same as Data.y++;
}
```

```java
// Every instance of Data will have a private copy of the instanced member x
// However it will point to the same location in memory for the member y
Data d1 = new Data(); // y = 1001
d1.x = 5;
Data d2 = new Data(); // y = 1002
d2.x = 25;
Data d3 = new Data(); // y = 1003
// ... and so on
```

### Méthodes Statiques

Les méthodes statiques représentent essentiellement un membre de fonction d'un certain type de classe

De la classe Data, rappelez-vous la fonction (méthode d'instance) `foo` et (méthode statique) `bar`

On peut accéder à ces méthodes via :

```java
Data d1 = new Data();

d1.foo(); // Instanced method: Accessible ONLY by an object

Data.bar(); // Static method: accessible without an object
```

### Initialiseur Statique

Utilisez un bloc *initialiseur statique* pour exécuter une logique d'initialisation lorsque la classe est chargée pour la première fois :

```java
class OtherData {
    private static int a = 12;
    private static int b;
    private static String msg;

    static {
        msg = "Initialization..."
        System.out.println(msg);
        b = 4;
        // ... complex initialization that can't be done in a single expression
    }
}
```

## Exercices Pratiques

1. **Créer une Classe `BankAccount`** :
   * Propriétés privées : accountNumber, balance
   * Constructeur pour définir le numéro de compte
   * Méthodes : deposit(), withdraw(), getBalance()
   * Validation : ne peut pas retirer plus que le solde
   * Le numéro de compte doit être en lecture seule

2. **Créer une Classe `Door`** :
   * Propriétés privées : isLocked, keyCode
   * Constructeur pour définir le code clé
   * Méthodes : lock(), unlock(String code), isLocked()
   * unlock() ne fonctionne qu'avec le bon code
   * Le code doit être privé (ne l'exposez pas !)

3. **Créer une Classe `PlayerStats`** :
   * Propriétés privées : strength, defense, speed
   * Constructeur pour définir toutes les stats
   * Getters pour toutes les stats
   * Méthode : getPowerLevel() qui retourne strength + defense + speed
   * Les stats ne peuvent pas être négatives ou supérieures à 100

4. **Refactoriser une Classe** : Prenez l'une de vos classes de la leçon précédente et ajoutez une encapsulation appropriée :
   * Rendez toutes les propriétés privées
   * Ajoutez les getters et setters appropriés
   * Ajoutez la validation là où c'est nécessaire
