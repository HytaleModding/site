---
title: 12 - Gestion des Exceptions
description: Apprenez à gérer les erreurs avec élégance dans vos programmes Java.
---

Les exceptions sont des erreurs qui se produisent pendant l'exécution de votre programme. Au lieu de planter, vous pouvez "attraper" ces erreurs et les gérer avec élégance.

## Qu'est-ce qu'une Exception ?

Une exception est un événement qui perturbe le flux normal de votre programme :

```java
String text = null;
System.out.println(text.length());  // NullPointerException - crashes!
```

Sans gestion, cela fait planter votre mod et casse le jeu !

## Blocs Try-Catch

Utilisez `try-catch` pour gérer les exceptions :

```java
try {
    // Code that might throw an exception
    String text = null;
    System.out.println(text.length());
} catch (NullPointerException e) {
    // Code to handle the error
    System.out.println("Error: text was null!");
}

System.out.println("Program continues...");
```

<Callout type="info" title="Comment Fonctionne Try-Catch">
  1. Le code dans le bloc `try` s'exécute normalement
  2. Si une exception se produit, l'exécution saute au bloc `catch`
  3. Après le bloc `catch`, le programme continue normalement
  4. Si aucune exception ne se produit, le bloc `catch` est ignoré

  ```java
  try {
      // Try to do something risky
      int result = 10 / 0;  // Division by zero!
  } catch (ArithmeticException e) {
      // Handle the error
      System.out.println("Can't divide by zero!");
  }
  // Program keeps running
  ```
</Callout>

## Types d'Exceptions Courants

### NullPointerException

Accès aux méthodes/propriétés sur des objets null :

```java
String name = null;

try {
    int length = name.length();
} catch (NullPointerException e) {
    System.out.println("Name is null!");
}
```

### ArrayIndexOutOfBoundsException

Accès à un index de tableau invalide :

```java
int[] numbers = {1, 2, 3};

try {
    int value = numbers[10];  // Index 10 doesn't exist!
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Invalid array index!");
}
```

### NumberFormatException

Conversion de chaînes invalides en nombres :

```java
try {
    int number = Integer.parseInt("abc");  // Not a number!
} catch (NumberFormatException e) {
    System.out.println("Invalid number format!");
}
```

### ArithmeticException

Erreurs mathématiques comme la division par zéro :

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Math error!");
}
```

## Blocs Catch Multiples

Gérez différentes exceptions différemment :

```java
String input = "abc";

try {
    int number = Integer.parseInt(input);
    int result = 100 / number;
    System.out.println(result);
} catch (NumberFormatException e) {
    System.out.println("Invalid number!");
} catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero!");
}
```

## Attraper Plusieurs Types d'Exceptions

Attrapez plusieurs exceptions dans un seul bloc :

```java
try {
    // Some risky code
} catch (NumberFormatException | ArithmeticException e) {
    System.out.println("Math-related error occurred!");
}
```

## Le Bloc Finally

Code qui s'exécute **toujours**, qu'une exception se produise ou non :

```java
try {
    System.out.println("Opening file...");
    // Code that might fail
} catch (Exception e) {
    System.out.println("Error: " + e.getMessage());
} finally {
    System.out.println("Closing file...");
    // This ALWAYS runs - good for cleanup
}
```

<Callout type="info" title="Quand Utiliser Finally">
  Utilisez `finally` pour les tâches de nettoyage qui doivent toujours se produire :

  - Fermer des fichiers
  - Libérer des ressources
  - Sauvegarder des données
  - Journalisation

  ```java
  FileReader file = null;
  try {
      file = new FileReader("data.txt");
      // Read file
  } catch (Exception e) {
      System.out.println("Error reading file");
  } finally {
      if (file != null) {
          file.close();  // Always close the file!
      }
  }
  ```
</Callout>

## Obtenir des Informations sur l'Exception

L'objet exception contient des informations utiles :

```java
try {
    int result = Integer.parseInt("xyz");
} catch (NumberFormatException e) {
    System.out.println("Message: " + e.getMessage());
    System.out.println("Type: " + e.getClass().getName());
    e.printStackTrace();  // Print full error details
}
```

## Exemples Pratiques

### Entrée de Joueur Sécurisée

```java
import java.util.Scanner;

public class PlayerInput {
    public static int getPlayerChoice(Scanner scanner) {
        while (true) {
            try {
                System.out.print("Enter choice (1-5): ");
                String input = scanner.nextLine();
                int choice = Integer.parseInt(input);
                
                if (choice < 1 || choice > 5) {
                    System.out.println("Please enter a number between 1 and 5");
                    continue;
                }
                
                return choice;
            } catch (NumberFormatException e) {
                System.out.println("Invalid input! Please enter a number.");
            }
        }
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int choice = getPlayerChoice(scanner);
        System.out.println("You chose: " + choice);
    }
}
```

### Mise à Jour Sécurisée de la Durabilité d'Objet

```java
public class Item {
    private String name;
    private int durability;
    private int maxDurability;
    
    public Item(String name, int maxDurability) {
        this.name = name;
        this.durability = maxDurability;
        this.maxDurability = maxDurability;
    }
    
    public void damage(int amount) {
        try {
            if (amount < 0) {
                throw new IllegalArgumentException("Damage cannot be negative!");
            }
            
            durability -= amount;
            
            if (durability < 0) {
                durability = 0;
            }
            
            System.out.println(name + " durability: " + durability + "/" + maxDurability);
            
            if (durability == 0) {
                System.out.println(name + " broke!");
            }
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
```

### Chargement Sécurisé de Configuration

```java
import java.util.HashMap;

public class ConfigLoader {
    private HashMap<String, String> settings;
    
    public ConfigLoader() {
        this.settings = new HashMap<>();
        loadDefaults();
    }
    
    private void loadDefaults() {
        settings.put("maxPlayers", "10");
        settings.put("difficulty", "normal");
        settings.put("pvpEnabled", "true");
    }
    
    public int getIntSetting(String key, int defaultValue) {
        try {
            String value = settings.get(key);
            if (value == null) {
                return defaultValue;
            }
            return Integer.parseInt(value);
        } catch (NumberFormatException e) {
            System.out.println("Invalid number for " + key + ", using default");
            return defaultValue;
        }
    }
    
    public boolean getBooleanSetting(String key, boolean defaultValue) {
        try {
            String value = settings.get(key);
            if (value == null) {
                return defaultValue;
            }
            return Boolean.parseBoolean(value);
        } catch (Exception e) {
            System.out.println("Invalid boolean for " + key + ", using default");
            return defaultValue;
        }
    }
    
    public void setSetting(String key, String value) {
        if (key == null || value == null) {
            System.out.println("Key and value cannot be null!");
            return;
        }
        settings.put(key, value);
    }
}
```

### Accès Sécurisé aux Tableaux

```java
public class Inventory {
    private String[] items;
    
    public Inventory(int size) {
        this.items = new String[size];
    }
    
    public boolean setItem(int slot, String item) {
        try {
            if (slot < 0 || slot >= items.length) {
                throw new ArrayIndexOutOfBoundsException("Invalid slot: " + slot);
            }
            
            items[slot] = item;
            System.out.println("Placed " + item + " in slot " + slot);
            return true;
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Error: " + e.getMessage());
            return false;
        }
    }
    
    public String getItem(int slot) {
        try {
            return items[slot];
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Invalid slot: " + slot);
            return null;
        }
    }
}
```

### Analyseur de Commande avec Gestion d'Erreurs

```java
public class CommandParser {
    public static void parseCommand(String command) {
        try {
            if (command == null || command.trim().isEmpty()) {
                throw new IllegalArgumentException("Command cannot be empty!");
            }
            
            String[] parts = command.split(" ");
            
            if (parts.length < 2) {
                throw new IllegalArgumentException("Invalid command format!");
            }
            
            String action = parts[0];
            String target = parts[1];
            
            switch (action) {
                case "give":
                    if (parts.length < 4) {
                        throw new IllegalArgumentException("Usage: give <player> <item> <amount>");
                    }
                    String item = parts[2];
                    int amount = Integer.parseInt(parts[3]);
                    
                    if (amount <= 0) {
                        throw new IllegalArgumentException("Amount must be positive!");
                    }
                    
                    System.out.println("Giving " + amount + " " + item + " to " + target);
                    break;
                    
                case "tp":
                    if (parts.length < 5) {
                        throw new IllegalArgumentException("Usage: tp <player> <x> <y> <z>");
                    }
                    int x = Integer.parseInt(parts[2]);
                    int y = Integer.parseInt(parts[3]);
                    int z = Integer.parseInt(parts[4]);
                    
                    System.out.println("Teleporting " + target + " to " + x + ", " + y + ", " + z);
                    break;
                    
                default:
                    throw new IllegalArgumentException("Unknown command: " + action);
            }
        } catch (NumberFormatException e) {
            System.out.println("Error: Invalid number in command!");
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Unexpected error: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) {
        parseCommand("give Steve diamond 5");
        parseCommand("give Steve sword abc");  // Invalid number
        parseCommand("tp Alice 10 64 20");
        parseCommand("unknown command");       // Unknown command
    }
}
```

## Lancer des Exceptions

Vous pouvez lancer vos propres exceptions :

```java
public class Player {
    private int health;
    
    public void setHealth(int health) {
        if (health < 0) {
            throw new IllegalArgumentException("Health cannot be negative!");
        }
        if (health > 100) {
            throw new IllegalArgumentException("Health cannot exceed 100!");
        }
        this.health = health;
    }
}
```

<Callout type="info" title="Quand Lancer des Exceptions">
  Lancez des exceptions quand :

  - La méthode reçoit une entrée invalide
  - L'opération ne peut pas être complétée
  - Les préconditions ne sont pas remplies
  - Quelque chose d'inattendu se produit

  ```java
  public void damagePlayer(int damage) {
      if (damage < 0) {
          throw new IllegalArgumentException("Damage must be positive!");
      }
      // Apply damage
  }

  public Item getItem(int slot) {
      if (slot < 0 || slot >= inventory.length) {
          throw new IndexOutOfBoundsException("Invalid inventory slot!");
      }
      return inventory[slot];
  }
  ```
</Callout>

## Exceptions Vérifiées vs Non Vérifiées

<Callout type="warning" title="Types d'Exceptions">
  **Exceptions Non Vérifiées** (RuntimeException) :

  - N'ont pas besoin d'être attrapées
  - Généralement des erreurs de programmation
  - Exemples : NullPointerException, ArrayIndexOutOfBoundsException

  **Exceptions Vérifiées** :

  - Doivent être attrapées ou déclarées
  - Généralement des erreurs externes (fichiers, réseau)
  - Exemples : IOException, FileNotFoundException

  ```java
  // Unchecked - no need to catch
  int result = 10 / 0;  // ArithmeticException

  // Checked - must catch or declare
  try {
      FileReader file = new FileReader("data.txt");  // IOException
  } catch (IOException e) {
      // Handle error
  }
  ```
</Callout>

## Exercices Pratiques

1. **Calculateur de Division Sécurisé** : Créez une méthode qui divise deux nombres. Gérez la division par zéro et les entrées invalides avec élégance.

2. **Définisseur de Niveau de Joueur** : Créez une méthode qui définit le niveau du joueur (1-100). Lancez une exception si invalide, et gérez-la dans main.

3. **Accès Sécurisé aux Tableaux** : Créez une méthode qui accède en toute sécurité aux éléments d'un tableau. Retournez null si l'index est invalide au lieu de planter.

4. **Analyseur de Configuration** : Lisez une chaîne de configuration comme "maxPlayers=10" et analysez-la. Gérez les formats invalides avec élégance.

5. **Validateur de Nom de Fichier** : Créez une méthode qui vérifie si un nom de fichier est valide (pas de caractères spéciaux, pas vide). Lancez des exceptions pour les noms invalides.
