---
title: 11 - HashMap et Stockage Clé-Valeur
description: Apprenez à stocker et récupérer des données en utilisant des paires clé-valeur.
---

Un `HashMap` stocke des données en paires clé-valeur, comme un dictionnaire du monde réel. Vous recherchez un mot (clé) pour trouver sa définition (valeur). C'est parfait pour les données de joueur, les propriétés d'objets et les paramètres de configuration.

## Bases de HashMap

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        // Create a HashMap (String keys, Integer values)
        HashMap<String, Integer> playerLevels = new HashMap<>();
        
        // Add key-value pairs
        playerLevels.put("Alice", 10);
        playerLevels.put("Bob", 15);
        playerLevels.put("Charlie", 8);
        
        // Get a value by key
        int aliceLevel = playerLevels.get("Alice");  // 10
        
        System.out.println("Alice is level " + aliceLevel);
    }
}
```

<Callout type="info" title="HashMap vs ArrayList">
  | **HashMap**                     | **ArrayList**                 |
  | ------------------------------- | ----------------------------- |
  | Non ordonné                     | Ordonné par index (0, 1, 2...)  |
  | Accès par clé (peut être n'importe quel type) | Accès par position            |
  | Bon pour rechercher des valeurs      | Bon pour les listes d'objets       |
  | Chaque clé est unique              | Peut avoir des doublons           |

  ```java
  // ArrayList - access by number
  ArrayList<String> players = new ArrayList<>();
  players.add("Alice");
  String player = players.get(0);  // Get first player

  // HashMap - access by name
  HashMap<String, Integer> levels = new HashMap<>();
  levels.put("Alice", 10);
  int level = levels.get("Alice");  // Get Alice's level
  ```
</Callout>

## Méthodes Courantes de HashMap

### Ajouter et Mettre à Jour

```java
HashMap<String, Integer> scores = new HashMap<>();

scores.put("Alice", 100);     // Add new entry
scores.put("Bob", 150);
scores.put("Alice", 200);     // Update existing (Alice now 200)
```

### Obtenir des Valeurs

```java
HashMap<String, Integer> scores = new HashMap<>();
scores.put("Alice", 100);

int score = scores.get("Alice");        // 100
Integer missing = scores.get("Dave");   // null (doesn't exist)

// Get with default value
int score2 = scores.getOrDefault("Dave", 0);  // 0 (returns default)
```

### Vérifier les Clés/Valeurs

```java
HashMap<String, Integer> scores = new HashMap<>();
scores.put("Alice", 100);

boolean hasAlice = scores.containsKey("Alice");    // true
boolean hasDave = scores.containsKey("Dave");      // false

boolean has100 = scores.containsValue(100);        // true
boolean has200 = scores.containsValue(200);        // false
```

### Supprimer des Entrées

```java
HashMap<String, Integer> scores = new HashMap<>();
scores.put("Alice", 100);
scores.put("Bob", 150);

scores.remove("Alice");           // Remove by key
System.out.println(scores);       // {Bob=150}

scores.clear();                   // Remove everything
System.out.println(scores);       // {}
```

### Taille et Vérification de Vide

```java
HashMap<String, Integer> scores = new HashMap<>();
scores.put("Alice", 100);

int size = scores.size();         // 1
boolean empty = scores.isEmpty(); // false
```

## Parcourir un HashMap

### Parcourir les Clés

```java
HashMap<String, Integer> scores = new HashMap<>();
scores.put("Alice", 100);
scores.put("Bob", 150);
scores.put("Charlie", 75);

for (String name : scores.keySet()) {
    System.out.println(name);
}
// Output: Alice, Bob, Charlie (order may vary)
```

### Parcourir les Valeurs

```java
for (Integer score : scores.values()) {
    System.out.println(score);
}
// Output: 100, 150, 75 (order may vary)
```

### Parcourir les Clés et Valeurs

```java
for (String name : scores.keySet()) {
    int score = scores.get(name);
    System.out.println(name + ": " + score);
}

// Or using entrySet (more efficient)
for (var entry : scores.entrySet()) {
    String name = entry.getKey();
    int score = entry.getValue();
    System.out.println(name + ": " + score);
}
```

<Callout type="info" title="Ordre de HashMap">
  HashMap ne **maintient pas** l'ordre d'insertion ! Si vous avez besoin d'ordre, utilisez `LinkedHashMap` :

  ```java
  import java.util.LinkedHashMap;

  LinkedHashMap<String, Integer> orderedScores = new LinkedHashMap<>();
  orderedScores.put("Alice", 100);
  orderedScores.put("Bob", 150);
  orderedScores.put("Charlie", 75);

  // Will print in insertion order
  for (String name : orderedScores.keySet()) {
      System.out.println(name);
  }
  // Output: Alice, Bob, Charlie (guaranteed order)
  ```
</Callout>

## Exemples Pratiques

### Système de Statistiques de Joueur

```java
import java.util.HashMap;

public class PlayerStats {
    private HashMap<String, Integer> stats;
    
    public PlayerStats() {
        this.stats = new HashMap<>();
        // Initialize default stats
        stats.put("health", 100);
        stats.put("mana", 50);
        stats.put("strength", 10);
        stats.put("defense", 5);
        stats.put("speed", 8);
    }
    
    public int getStat(String statName) {
        return stats.getOrDefault(statName, 0);
    }
    
    public void setStat(String statName, int value) {
        stats.put(statName, value);
    }
    
    public void modifyStat(String statName, int amount) {
        int current = getStat(statName);
        stats.put(statName, current + amount);
    }
    
    public void displayStats() {
        System.out.println("=== Player Stats ===");
        for (var entry : stats.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        PlayerStats stats = new PlayerStats();
        stats.displayStats();
        
        stats.modifyStat("strength", 5);
        stats.modifyStat("health", -20);
        
        System.out.println("\nAfter modifications:");
        stats.displayStats();
    }
}
```

### Base de Données de Propriétés d'Objets

```java
import java.util.HashMap;

public class ItemDatabase {
    private HashMap<String, HashMap<String, Object>> items;
    
    public ItemDatabase() {
        this.items = new HashMap<>();
    }
    
    public void addItem(String itemName) {
        HashMap<String, Object> properties = new HashMap<>();
        properties.put("damage", 0);
        properties.put("durability", 100);
        properties.put("rarity", "Common");
        properties.put("stackable", true);
        
        items.put(itemName, properties);
    }
    
    public void setProperty(String itemName, String property, Object value) {
        if (items.containsKey(itemName)) {
            items.get(itemName).put(property, value);
        }
    }
    
    public Object getProperty(String itemName, String property) {
        if (items.containsKey(itemName)) {
            return items.get(itemName).get(property);
        }
        return null;
    }
    
    public void displayItem(String itemName) {
        if (!items.containsKey(itemName)) {
            System.out.println("Item not found!");
            return;
        }
        
        System.out.println("=== " + itemName + " ===");
        HashMap<String, Object> props = items.get(itemName);
        for (var entry : props.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        ItemDatabase db = new ItemDatabase();
        
        db.addItem("Iron Sword");
        db.setProperty("Iron Sword", "damage", 15);
        db.setProperty("Iron Sword", "rarity", "Uncommon");
        
        db.displayItem("Iron Sword");
    }
}
```

### Gestionnaire de Configuration

```java
import java.util.HashMap;

public class GameConfig {
    private HashMap<String, String> settings;
    
    public GameConfig() {
        this.settings = new HashMap<>();
        loadDefaults();
    }
    
    private void loadDefaults() {
        settings.put("difficulty", "normal");
        settings.put("musicVolume", "50");
        settings.put("sfxVolume", "50");
        settings.put("renderDistance", "10");
        settings.put("showFPS", "false");
    }
    
    public String getSetting(String key) {
        return settings.getOrDefault(key, "");
    }
    
    public void setSetting(String key, String value) {
        settings.put(key, value);
        System.out.println("Set " + key + " to " + value);
    }
    
    public int getIntSetting(String key) {
        String value = getSetting(key);
        try {
            return Integer.parseInt(value);
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    public boolean getBooleanSetting(String key) {
        return "true".equalsIgnoreCase(getSetting(key));
    }
    
    public void displaySettings() {
        System.out.println("=== Game Settings ===");
        for (var entry : settings.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
    }
}
```

### Inventaire de Joueur avec Quantités

```java
import java.util.HashMap;

public class Inventory {
    private HashMap<String, Integer> items;
    private int maxSlots;
    
    public Inventory(int maxSlots) {
        this.items = new HashMap<>();
        this.maxSlots = maxSlots;
    }
    
    public boolean addItem(String itemName, int quantity) {
        if (items.size() >= maxSlots && !items.containsKey(itemName)) {
            System.out.println("Inventory full!");
            return false;
        }
        
        int current = items.getOrDefault(itemName, 0);
        items.put(itemName, current + quantity);
        System.out.println("Added " + quantity + "x " + itemName);
        return true;
    }
    
    public boolean removeItem(String itemName, int quantity) {
        if (!items.containsKey(itemName)) {
            System.out.println("Don't have that item!");
            return false;
        }
        
        int current = items.get(itemName);
        if (current < quantity) {
            System.out.println("Not enough " + itemName);
            return false;
        }
        
        if (current == quantity) {
            items.remove(itemName);
        } else {
            items.put(itemName, current - quantity);
        }
        
        System.out.println("Removed " + quantity + "x " + itemName);
        return true;
    }
    
    public int getQuantity(String itemName) {
        return items.getOrDefault(itemName, 0);
    }
    
    public boolean hasItem(String itemName) {
        return items.containsKey(itemName);
    }
    
    public void displayInventory() {
        System.out.println("\n=== Inventory (" + items.size() + "/" + maxSlots + " slots) ===");
        if (items.isEmpty()) {
            System.out.println("Empty");
        } else {
            for (var entry : items.entrySet()) {
                System.out.println(entry.getKey() + " x" + entry.getValue());
            }
        }
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        Inventory inv = new Inventory(10);
        
        inv.addItem("Wood", 64);
        inv.addItem("Stone", 32);
        inv.addItem("Wood", 20);  // Adds to existing
        
        inv.displayInventory();
        
        inv.removeItem("Wood", 50);
        inv.displayInventory();
    }
}
```

### Gestionnaire de Temps de Recharge

```java
import java.util.HashMap;

public class CooldownManager {
    private HashMap<String, Long> cooldowns;
    
    public CooldownManager() {
        this.cooldowns = new HashMap<>();
    }
    
    public void startCooldown(String ability, long durationMs) {
        long endTime = System.currentTimeMillis() + durationMs;
        cooldowns.put(ability, endTime);
        System.out.println(ability + " on cooldown for " + (durationMs / 1000) + " seconds");
    }
    
    public boolean isOnCooldown(String ability) {
        if (!cooldowns.containsKey(ability)) {
            return false;
        }
        
        long endTime = cooldowns.get(ability);
        long now = System.currentTimeMillis();
        
        if (now >= endTime) {
            cooldowns.remove(ability);
            return false;
        }
        
        return true;
    }
    
    public long getRemainingTime(String ability) {
        if (!isOnCooldown(ability)) {
            return 0;
        }
        
        long endTime = cooldowns.get(ability);
        long now = System.currentTimeMillis();
        return (endTime - now) / 1000;  // Return seconds
    }
    
    public boolean useAbility(String ability, long cooldownSeconds) {
        if (isOnCooldown(ability)) {
            long remaining = getRemainingTime(ability);
            System.out.println(ability + " is on cooldown (" + remaining + "s remaining)");
            return false;
        }
        
        System.out.println("Used " + ability + "!");
        startCooldown(ability, cooldownSeconds * 1000);
        return true;
    }
}
```

## HashMap avec Objets Personnalisés

Stockez vos propres classes comme valeurs :

```java
public class Player {
    private String name;
    private int level;
    private int health;
    
    public Player(String name, int level) {
        this.name = name;
        this.level = level;
        this.health = 100;
    }
    
    // Getters and setters...
    
    @Override
    public String toString() {
        return name + " (Lv. " + level + ", HP: " + health + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        HashMap<String, Player> players = new HashMap<>();
        
        players.put("player1", new Player("Alice", 10));
        players.put("player2", new Player("Bob", 15));
        
        // Get and use player
        Player alice = players.get("player1");
        System.out.println(alice);
    }
}
```

## HashMaps Imbriqués

Les HashMaps peuvent contenir d'autres HashMaps :

```java
// Store multiple properties per player
HashMap<String, HashMap<String, Integer>> playerData = new HashMap<>();

// Add player with stats
HashMap<String, Integer> aliceStats = new HashMap<>();
aliceStats.put("level", 10);
aliceStats.put("health", 100);
aliceStats.put("mana", 50);
playerData.put("Alice", aliceStats);

// Access nested data
int aliceLevel = playerData.get("Alice").get("level");
System.out.println("Alice's level: " + aliceLevel);
```

## Exercices Pratiques

1. **Annuaire Téléphonique** : Créez un annuaire qui stocke des noms et numéros de téléphone. Ajoutez des méthodes pour :
   - Ajouter un contact
   - Trouver un numéro par nom
   - Supprimer un contact
   - Afficher tous les contacts

2. **Gestionnaire de Notes** : Stockez les noms d'étudiants et leurs notes. Créez des méthodes pour :
   - Ajouter un étudiant avec une note
   - Mettre à jour une note
   - Calculer la moyenne de la classe
   - Trouver la note la plus élevée

3. **Compteur de Mots** : Écrivez un programme qui compte combien de fois chaque mot apparaît dans une phrase en utilisant un HashMap.

4. **Boutique d'Objets** : Créez une boutique où les objets ont des noms et des prix. Ajoutez des méthodes pour :
   - Ajouter un objet avec un prix
   - Obtenir le prix d'un objet
   - Appliquer une réduction à tous les objets
   - Afficher tous les objets et prix

---
