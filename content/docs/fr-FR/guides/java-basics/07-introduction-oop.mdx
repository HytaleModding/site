---
title: 07 - Introduction à la Programmation Orientée Objet
description: Apprenez les fondamentaux des classes et objets en Java.
---

La Programmation Orientée Objet (POO) est le fondement de Java et du modding Hytale. Au lieu d'avoir simplement des variables et des méthodes qui flottent, nous les organisons en **classes** et **objets**.

## Qu'est-ce qu'une Classe ?

Une classe est un plan pour créer des objets. Pensez-y comme une recette ou un modèle.

```java
public class Player {
    // Properties (data)
    String name;
    int health;
    int level;
    
    // Behavior (methods)
    public void takeDamage(int damage) {
        health -= damage;
        System.out.println(name + " took " + damage + " damage!");
    }
}
```

## Qu'est-ce qu'un Objet ?

Un objet est une instance créée à partir d'une classe. Si une classe est un plan, un objet est la chose réelle construite à partir de ce plan.

```java
public class Main {
    public static void main(String[] args) {
        // Create objects from the Player class
        Player player1 = new Player();
        player1.name = "Alice";
        player1.health = 100;
        player1.level = 5;
        
        Player player2 = new Player();
        player2.name = "Bob";
        player2.health = 80;
        player2.level = 3;
        
        // Use the objects
        player1.takeDamage(20);  // Alice took 20 damage!
        player2.takeDamage(15);  // Bob took 15 damage!
    }
}
```

<Callout type="info" title="Classe vs Objet">
  **Classe** = Plan (l'idée d'un joueur)
  **Objet** = Chose réelle (Alice, Bob, joueurs spécifiques)

  Une classe peut créer de nombreux objets, tout comme une recette peut faire de nombreux gâteaux !
</Callout>

## Créer une Classe Simple

Créons une classe `Sword` pour Hytale :

```java
public class Sword {
    // Properties
    String name;
    int damage;
    int durability;
    
    // Method to use the sword
    public void attack(String target) {
        System.out.println("Attacking " + target + " for " + damage + " damage!");
        durability -= 1;
        
        if (durability <= 0) {
            System.out.println(name + " broke!");
        }
    }
    
    // Method to display info
    public void displayInfo() {
        System.out.println("Weapon: " + name);
        System.out.println("Damage: " + damage);
        System.out.println("Durability: " + durability);
    }
}
```

Utilisation de la classe :

```java
public class Main {
    public static void main(String[] args) {
        Sword sword = new Sword();
        sword.name = "Iron Sword";
        sword.damage = 15;
        sword.durability = 3;
        
        sword.displayInfo();
        sword.attack("Zombie");
        sword.attack("Skeleton");
        sword.attack("Spider");  // This will break the sword
    }
}
```

## Constructeurs

Au lieu de définir les propriétés une par une, utilisez un **constructeur** pour initialiser les objets :

```java
public class Sword {
    String name;
    int damage;
    int durability;
    
    // Constructor
    public Sword(String weaponName, int weaponDamage, int weaponDurability) {
        name = weaponName;
        damage = weaponDamage;
        durability = weaponDurability;
    }
    
    public void attack(String target) {
        System.out.println("Attacking " + target + " for " + damage + " damage!");
        durability--;
    }
}
```

Maintenant créer des épées est plus facile :

```java
public class Main {
    public static void main(String[] args) {
        // Much cleaner!
        Sword ironSword = new Sword("Iron Sword", 15, 100);
        Sword diamondSword = new Sword("Diamond Sword", 25, 200);
        
        ironSword.attack("Zombie");
        diamondSword.attack("Boss");
    }
}
```

<Callout type="info" title="Règles des Constructeurs">
  * Même nom que la classe
  * Pas de type de retour (même pas `void`)
  * Appelé automatiquement quand vous utilisez `new`
  * Peut avoir plusieurs constructeurs (surcharge)

  ```java
  public class Item {
      String name;
      int value;
      
      // Constructor with all parameters
      public Item(String name, int value) {
          this.name = name;
          this.value = value;
      }
      
      // Constructor with just name
      public Item(String name) {
          this.name = name;
          this.value = 0;  // Default value
      }
  }
  ```
</Callout>

## Le Mot-clé `this`

`this` fait référence à l'objet actuel. Utilisez-le pour clarifier quand les noms de paramètres correspondent aux noms de propriétés :

```java
public class Player {
    String name;
    int health;
    
    public Player(String name, int health) {
        this.name = name;      // this.name = the property
        this.health = health;  // name = the parameter
    }
}
```

Sans `this`, Java est confus :

```java
public Player(String name, int health) {
    name = name;      // ❌ Which name? Ambiguous!
    health = health;  // ❌ Which health? Ambiguous!
}
```

## Exemples Pratiques

### Classe Item

```java
public class Item {
    String name;
    String type;
    int quantity;
    double weight;
    
    public Item(String name, String type, int quantity, double weight) {
        this.name = name;
        this.type = type;
        this.quantity = quantity;
        this.weight = weight;
    }
    
    public void use() {
        if (quantity > 0) {
            quantity--;
            System.out.println("Used " + name + ". Remaining: " + quantity);
        } else {
            System.out.println("No more " + name + " left!");
        }
    }
    
    public double getTotalWeight() {
        return weight * quantity;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Item potion = new Item("Health Potion", "Consumable", 5, 0.5);
        
        potion.use();  // Used Health Potion. Remaining: 4
        System.out.println("Total weight: " + potion.getTotalWeight()); // 2.0
    }
}
```

### Classe Monster

```java
public class Monster {
    String name;
    int health;
    int attack;
    boolean isHostile;
    
    public Monster(String name, int health, int attack, boolean isHostile) {
        this.name = name;
        this.health = health;
        this.attack = attack;
        this.isHostile = isHostile;
    }
    
    public void takeDamage(int damage) {
        health -= damage;
        System.out.println(name + " took " + damage + " damage!");
        
        if (health <= 0) {
            System.out.println(name + " was defeated!");
        } else {
            System.out.println(name + " has " + health + " health left.");
        }
    }
    
    public int attackPlayer() {
        if (isHostile && health > 0) {
            System.out.println(name + " attacks for " + attack + " damage!");
            return attack;
        }
        return 0;
    }
    
    public boolean isAlive() {
        return health > 0;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Monster zombie = new Monster("Zombie", 50, 10, true);
        Monster chicken = new Monster("Chicken", 10, 0, false);
        
        zombie.takeDamage(20);        // Zombie took 20 damage!
        int damage = zombie.attackPlayer();  // Zombie attacks for 10 damage!
        
        if (zombie.isAlive()) {
            System.out.println("Monster is still alive!");
        }
    }
}
```

### Classe Block

```java
public class Block {
    String type;
    int x, y, z;
    boolean isSolid;
    int hardness;
    
    public Block(String type, int x, int y, int z, boolean isSolid, int hardness) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.z = z;
        this.isSolid = isSolid;
        this.hardness = hardness;
    }
    
    public void breakBlock() {
        System.out.println("Breaking " + type + " block at (" + x + ", " + y + ", " + z + ")");
        System.out.println("Hardness: " + hardness);
    }
    
    public String getPosition() {
        return "(" + x + ", " + y + ", " + z + ")";
    }
    
    public boolean canWalkThrough() {
        return !isSolid;
    }
}
```

## Modificateurs d'Accès (Aperçu)

Vous avez vu `public` - cela signifie "tout le monde peut y accéder". Nous en apprendrons plus sur le contrôle d'accès plus tard, mais voici un aperçu :

```java
public class Example {
    public String publicVar;      // Anyone can access
    private String privateVar;    // Only this class can access
    /* (no modifier) */ String defaultVar; // Package access
}
```

Pour l'instant, utilisez `public` pour tout. Nous apprendrons quand utiliser `private` dans le prochain article.

<Callout type="info" title="Pourquoi Utiliser des Classes ?">
  Les classes vous aident à :

  * **Organiser** les données et méthodes connexes ensemble
  * **Réutiliser** le code facilement (créer de nombreux objets à partir d'une classe)
  * **Modéliser** des choses du monde réel (joueurs, objets, monstres)
  * **Maintenir** le code (les changements à un endroit affectent tous les objets)

  Sans classes, gérer 100 joueurs nécessiterait 100 variables séparées pour chaque propriété. Avec les classes, ce ne sont que 100 objets Player !
</Callout>

## Exercices Pratiques

1. **Créer une Classe `Potion`** :
   * Propriétés : name, healAmount, uses
   * Constructeur pour définir toutes les propriétés
   * Méthode `drink()` qui soigne et diminue les utilisations
   * Méthode `isEmpty()` qui retourne vrai si les utilisations sont inférieures ou égales à 0

2. **Créer une Classe `Chest`** :
   * Propriétés : isLocked, itemCount, capacity
   * Constructeur
   * Méthode `addItem()` qui vérifie la capacité
   * Méthode `unlock()` qui définit isLocked à faux
   * Méthode `isFull()` qui vérifie si itemCount >= capacity

3. **Créer une Classe `Villager`** :
   * Propriétés : name, profession, tradeCount
   * Constructeur
   * Méthode `greet()` qui affiche un message de bienvenue
   * Méthode `trade()` qui augmente tradeCount
   * Méthode `getInfo()` qui affiche toutes les propriétés

4. **Créer Plusieurs Objets** : En utilisant n'importe quelle classe que vous avez créée, créez 3 objets différents et testez toutes leurs méthodes.
