---
title: 13 - Héritage
description: Apprenez à créer des hiérarchies de classes et à réutiliser le code efficacement.
---

L'héritage vous permet de créer de nouvelles classes basées sur des classes existantes. La nouvelle classe hérite de toutes les propriétés et méthodes de la classe parente, et peut ajouter les siennes ou modifier celles héritées.

## Qu'est-ce que l'Héritage ?

Pensez à l'héritage comme un arbre généalogique. Un enfant hérite des traits de son parent, mais peut aussi avoir ses propres traits uniques.

```java
// Parent class (superclass)
public class Entity {
    protected String name;
    protected int health;
    
    public Entity(String name, int health) {
        this.name = name;
        this.health = health;
    }
    
    public void takeDamage(int damage) {
        health -= damage;
        System.out.println(name + " took " + damage + " damage!");
    }
}

// Child class (subclass)
public class Player extends Entity {
    private int level;
    
    public Player(String name, int health, int level) {
        super(name, health);  // Call parent constructor
        this.level = level;
    }
    
    public void levelUp() {
        level++;
        System.out.println(name + " leveled up to " + level + "!");
    }
}
```

<Callout type="info" title="Terminologie de l'Héritage">
  - **Superclasse/Parent** : La classe dont on hérite (Entity)
  - **Sous-classe/Enfant** : La classe qui hérite (Player)
  - **extends** : Mot-clé pour hériter d'une classe
  - **super** : Mot-clé pour accéder aux membres de la classe parente

  ```java
  public class Monster extends Entity {
      // Monster EST-UN Entity
      // Monster hérite de Entity
      // Entity est le parent, Monster est l'enfant
  }
  ```
</Callout>

## Le Mot-clé extends

Utilisez `extends` pour hériter d'une classe :

```java
public class Animal {
    protected String name;
    
    public void makeSound() {
        System.out.println(name + " makes a sound");
    }
}

public class Dog extends Animal {
    public void wagTail() {
        System.out.println(name + " wags tail");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "Buddy";
        dog.makeSound();  // Inherited from Animal
        dog.wagTail();    // Dog's own method
    }
}
```

## Le Mot-clé super

`super` fait référence à la classe parente :

### Appeler le Constructeur Parent

```java
public class Entity {
    protected String name;
    
    public Entity(String name) {
        this.name = name;
    }
}

public class Player extends Entity {
    private int level;
    
    public Player(String name, int level) {
        super(name);  // Call parent constructor FIRST
        this.level = level;
    }
}
```

<Callout type="warning" title="Règles des Constructeurs">
  - `super()` doit être la **première** instruction dans le constructeur enfant
  - Si vous n'appelez pas `super()`, Java appelle automatiquement le constructeur parent sans argument
  - Si le parent n'a pas de constructeur sans argument, vous DEVEZ appeler `super()` avec des arguments

  ```java
  // Wrong - super() not first
  public Player(String name, int level) {
      this.level = level;
      super(name);  // Error!
  }

  // Correct
  public Player(String name, int level) {
      super(name);  // First statement
      this.level = level;
  }
  ```
</Callout>

### Appeler les Méthodes Parentes

```java
public class Entity {
    protected int health;
    
    public void takeDamage(int damage) {
        health -= damage;
        System.out.println("Entity took damage!");
    }
}

public class Player extends Entity {
    @Override
    public void takeDamage(int damage) {
        super.takeDamage(damage);  // Call parent version
        if (health < 20) {
            System.out.println("Warning: Low health!");
        }
    }
}
```

## Redéfinition de Méthode

Les classes enfants peuvent remplacer les méthodes parentes :

```java
public class Entity {
    public void attack() {
        System.out.println("Entity attacks!");
    }
}

public class Player extends Entity {
    @Override  // Good practice to use this annotation
    public void attack() {
        System.out.println("Player swings sword!");
    }
}

public class Monster extends Entity {
    @Override
    public void attack() {
        System.out.println("Monster bites!");
    }
}

public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        Monster monster = new Monster();
        
        player.attack();   // "Player swings sword!"
        monster.attack();  // "Monster bites!"
    }
}
```

<Callout type="info" title="Annotation @Override">
  Utilisez toujours `@Override` lors de la redéfinition de méthodes :

  - Aide à détecter les fautes de frappe (si la méthode n'existe pas dans le parent, vous obtenez une erreur)
  - Rend le code plus clair
  - Bonne documentation

  ```java
  // Without @Override - typo not caught
  public void attac() {  // Typo! Creates new method instead
      // ...
  }

  // With @Override - error caught immediately
  @Override
  public void attac() {  // Error: method doesn't exist in parent
      // ...
  }
  ```
</Callout>

## Modificateurs d'Accès dans l'Héritage

- `public` - Accessible partout
- `protected` - Accessible dans la classe et les sous-classes
- `private` - Seulement dans la classe (non hérité)

```java
public class Parent {
    public int publicVar;      // Child can access
    protected int protectedVar; // Child can access
    private int privateVar;     // Child CANNOT access
    
    private void privateMethod() {
        // Child cannot call this
    }
    
    protected void protectedMethod() {
        // Child can call this
    }
}

public class Child extends Parent {
    public void test() {
        publicVar = 10;      // OK
        protectedVar = 20;   // OK
        privateVar = 30;     // Error!
        
        protectedMethod();   // OK
        privateMethod();     // Error!
    }
}
```

## Exemples Pratiques

### Hiérarchie d'Entités de Jeu

```java
// Base class for all entities
public class Entity {
    protected String name;
    protected int health;
    protected int maxHealth;
    protected double x, y, z;
    
    public Entity(String name, int maxHealth) {
        this.name = name;
        this.health = maxHealth;
        this.maxHealth = maxHealth;
    }
    
    public void takeDamage(int damage) {
        health -= damage;
        if (health < 0) health = 0;
        System.out.println(name + " took " + damage + " damage. Health: " + health);
    }
    
    public boolean isAlive() {
        return health > 0;
    }
    
    public void moveTo(double x, double y, double z) {
        this.x = x;
        this.y = y;
        this.z = z;
        System.out.println(name + " moved to (" + x + ", " + y + ", " + z + ")");
    }
}

// Player extends Entity
public class Player extends Entity {
    private int level;
    private int experience;
    private int mana;
    
    public Player(String name) {
        super(name, 100);
        this.level = 1;
        this.experience = 0;
        this.mana = 50;
    }
    
    public void gainExperience(int amount) {
        experience += amount;
        System.out.println("Gained " + amount + " XP");
        
        if (experience >= level * 100) {
            levelUp();
        }
    }
    
    private void levelUp() {
        level++;
        maxHealth += 10;
        health = maxHealth;
        mana += 5;
        System.out.println("Level up! Now level " + level);
    }
    
    @Override
    public void takeDamage(int damage) {
        super.takeDamage(damage);
        if (health < maxHealth * 0.25) {
            System.out.println("⚠ WARNING: Low health!");
        }
    }
}

// Monster extends Entity
public class Monster extends Entity {
    private int attackPower;
    private String type;
    
    public Monster(String name, int health, int attackPower, String type) {
        super(name, health);
        this.attackPower = attackPower;
        this.type = type;
    }
    
    public int attack() {
        System.out.println(name + " attacks!");
        return attackPower;
    }
    
    @Override
    public void takeDamage(int damage) {
        super.takeDamage(damage);
        if (!isAlive()) {
            System.out.println(name + " was defeated!");
        }
    }
}

// Boss extends Monster (multi-level inheritance)
public class Boss extends Monster {
    private int phase;
    
    public Boss(String name, int health, int attackPower) {
        super(name, health, attackPower, "Boss");
        this.phase = 1;
    }
    
    @Override
    public void takeDamage(int damage) {
        super.takeDamage(damage);
        
        // Change phase at 50% health
        if (phase == 1 && health < maxHealth / 2) {
            phase = 2;
            System.out.println(name + " enters PHASE 2!");
        }
    }
    
    @Override
    public int attack() {
        int damage = super.attack();
        if (phase == 2) {
            damage *= 2;
            System.out.println("ENRAGED ATTACK!");
        }
        return damage;
    }
}
```

### Hiérarchie d'Objets

```java
// Base Item class
public class Item {
    protected String name;
    protected int value;
    protected double weight;
    
    public Item(String name, int value, double weight) {
        this.name = name;
        this.value = value;
        this.weight = weight;
    }
    
    public void use() {
        System.out.println("Using " + name);
    }
    
    public String getInfo() {
        return name + " ($" + value + ", " + weight + " kg)";
    }
}

// Weapon extends Item
public class Weapon extends Item {
    private int damage;
    private int durability;
    
    public Weapon(String name, int value, double weight, int damage, int durability) {
        super(name, value, weight);
        this.damage = damage;
        this.durability = durability;
    }
    
    @Override
    public void use() {
        if (durability > 0) {
            System.out.println("Attacking with " + name + " for " + damage + " damage!");
            durability--;
        } else {
            System.out.println(name + " is broken!");
        }
    }
    
    @Override
    public String getInfo() {
        return super.getInfo() + ", Damage: " + damage + ", Durability: " + durability;
    }
}

// Consumable extends Item
public class Consumable extends Item {
    private int healAmount;
    private int uses;
    
    public Consumable(String name, int value, double weight, int healAmount, int uses) {
        super(name, value, weight);
        this.healAmount = healAmount;
        this.uses = uses;
    }
    
    @Override
    public void use() {
        if (uses > 0) {
            System.out.println("Used " + name + ", restored " + healAmount + " health!");
            uses--;
        } else {
            System.out.println("No " + name + " left!");
        }
    }
    
    @Override
    public String getInfo() {
        return super.getInfo() + ", Heals: " + healAmount + ", Uses: " + uses;
    }
}

// Armor extends Item
public class Armor extends Item {
    private int defense;
    private String slot;
    
    public Armor(String name, int value, double weight, int defense, String slot) {
        super(name, value, weight);
        this.defense = defense;
        this.slot = slot;
    }
    
    @Override
    public void use() {
        System.out.println("Equipped " + name + " (+" + defense + " defense)");
    }
    
    @Override
    public String getInfo() {
        return super.getInfo() + ", Defense: " + defense + ", Slot: " + slot;
    }
}
```

## Polymorphisme

Les objets enfants peuvent être traités comme des objets parents :

```java
Entity entity1 = new Player("Alice");
Entity entity2 = new Monster("Goblin", 50, 10, "Hostile");
Entity entity3 = new Boss("Dragon", 500, 50);

// All can use Entity methods
entity1.takeDamage(10);
entity2.takeDamage(10);
entity3.takeDamage(10);

// Array of different types
Entity[] entities = {
    new Player("Bob"),
    new Monster("Zombie", 30, 8, "Hostile"),
    new Monster("Spider", 20, 5, "Hostile")
};

// Process all entities the same way
for (Entity entity : entities) {
    entity.takeDamage(5);
}
```

<Callout type="info" title="Avantages du Polymorphisme">
  Le polymorphisme vous permet d'écrire du code qui fonctionne avec des types parents mais gère correctement les types enfants :

  ```java
  public void damageEntity(Entity entity, int damage) {
      entity.takeDamage(damage);
      // Works for Player, Monster, Boss, etc.
      // Each uses their own version of takeDamage()
  }

  // Can call with any Entity type
  damageEntity(new Player("Alice"), 10);
  damageEntity(new Monster("Goblin", 50, 10, "Hostile"), 10);
  damageEntity(new Boss("Dragon", 500, 50), 10);
  ```
</Callout>

## La Classe Object

Toutes les classes en Java héritent automatiquement de `Object` :

```java
public class MyClass {
    // Automatically extends Object
    // Has methods like toString(), equals(), etc.
}
```

Méthodes Object courantes à redéfinir :

```java
public class Player {
    private String name;
    private int level;
    
    @Override
    public String toString() {
        return "Player: " + name + " (Lv. " + level + ")";
    }
    
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Player) {
            Player other = (Player) obj;
            return this.name.equals(other.name);
        }
        return false;
    }
}
```

## Classes et Méthodes Finales

`final` empêche l'héritage ou la redéfinition :

```java
// Final class - cannot be extended
public final class SpecialItem {
    // No class can extend this
}

// Final method - cannot be overridden
public class Entity {
    public final void printName() {
        System.out.println(name);
    }
}

public class Player extends Entity {
    @Override
    public void printName() {  // Error! Method is final
        // Cannot override
    }
}
```

## Erreurs Courantes

```java
// Wrong - Forgetting super()
public class Player extends Entity {
    public Player(String name) {
        // Error! Entity has no no-arg constructor
    }
}

// Correct
public class Player extends Entity {
    public Player(String name) {
        super(name, 100);  // Call parent constructor
    }
}

// Wrong - Accessing private members
public class Child extends Parent {
    public void test() {
        privateVar = 10;  // Error! private is not inherited
    }
}

// Correct - Use protected
public class Parent {
    protected int protectedVar;  // Child can access
}

// Wrong - Multiple inheritance (not allowed in Java)
public class Child extends Parent1, Parent2 {  // Error!
}

// Correct - Single inheritance only
public class Child extends Parent {
}
```

## Exercices Pratiques

1. **Hiérarchie de Véhicules** : Créez une classe `Vehicle` avec des propriétés comme vitesse et carburant. Créez des sous-classes `Car` et `Motorcycle` avec leurs propres fonctionnalités uniques.

2. **Calculateur de Formes** : Créez une classe `Shape` avec une méthode `calculateArea()`. Créez des sous-classes `Circle`, `Rectangle` et `Triangle` qui redéfinissent cette méthode.

3. **Personnages RPG** : Créez une classe `Character`. Étendez-la pour créer des classes `Warrior`, `Mage` et `Archer` avec des capacités uniques.

4. **Sons d'Animaux** : Créez une classe `Animal` avec une méthode `makeSound()`. Créez diverses sous-classes d'animaux qui redéfinissent cette méthode.
